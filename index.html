<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Atelier 3D Universel</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* --- VARIABLES & THEME --- */
        :root {
            --bg-gradient: radial-gradient(circle at top, #ffffff 0%, #e0e7ff 45%, #c7d2fe 75%, #94a3b8 100%);
            --dock-bg: rgba(255, 255, 255, 0.95);
            --text-color: #1e293b;
            --input-bg: transparent;
            --input-color: #1e293b;
            --icon-color: #94a3b8;
            --accent: #3b82f6;
            /* Couleur des bordures/pistes de slider par défaut */
            --border-color: #cbd5e1; 
            --list-item-bg: #f8fafc;
            --nav-btn-bg: transparent;
            --nav-btn-color: #64748b;
            /* Couleur de l'anneau de visibilité des couleurs non sélectionnées */
            --color-ring: rgba(0, 0, 0, 0.15); 
        }

        body.dark-mode {
            /* Fond gris sombre mais pas noir absolu pour bien voir la pièce */
            --bg-gradient: radial-gradient(circle at top, #475569 0%, #0f172a 100%);
            --dock-bg: rgba(15, 23, 42, 0.95);
            --text-color: #f1f5f9;
            --input-color: #ffffff;
            --icon-color: #64748b;
            --accent: #60a5fa;
            /* Piste de slider plus claire pour le contraste sombre */
            --border-color: #475569; 
            --list-item-bg: #1e293b;
            --nav-btn-bg: rgba(255,255,255,0.05);
            --nav-btn-color: #94a3b8;
            /* Anneau de visibilité plus clair pour le fond sombre */
            --color-ring: rgba(255, 255, 255, 0.25);
        }

        /* --- BASE --- */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg-gradient);
            color: var(--text-color);
            transition: background 0.5s;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        /* --- UI DOCK (Horizontal Strip) --- */
        #ui-dock {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 140px;
            background: var(--dock-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top-left-radius: 24px;
            border-top-right-radius: 24px;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.2);
            z-index: 50;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, background 0.3s;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        #ui-dock.minimized {
            transform: translateY(100%);
        }

        /* --- PROGRESS BAR --- */
        .progress-track {
            display: flex;
            height: 4px;
            width: 100%;
            padding: 0 20px;
            margin-top: 12px;
            box-sizing: border-box;
            gap: 4px;
            justify-content: center;
        }
        .prog-dot {
            flex: 1;
            max-width: 30px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            transition: 0.3s;
        }
        .prog-dot.active { background: var(--accent); }
        .prog-dot.completed { background: var(--accent); opacity: 0.5; }

        /* --- MAIN ROW --- */
        .dock-row {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            width: 100%;
            box-sizing: border-box;
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: var(--nav-btn-bg);
            color: var(--nav-btn-color);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            flex-shrink: 0;
        }
        .nav-btn:active { transform: scale(0.9); }
        .nav-btn:disabled { opacity: 0.2; cursor: default; }
        .nav-btn.primary { color: var(--accent); }

        .tool-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 0 10px;
            overflow: hidden;
        }

        /* Step Indicator (Left Icon) */
        .step-indicator-icon {
            font-size: 26px;
            color: var(--accent);
            margin-right: 12px;
            padding-right: 12px;
            border-right: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            height: 36px;
            flex-shrink: 0;
        }

        .step {
            display: none;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: center;
            animation: fadeInRight 0.3s ease;
        }
        .step.active { display: flex; }
        
        @keyframes fadeInRight {
            from { opacity: 0; transform: translateX(10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* 1. Input Text */
        input[type="text"] {
            background: var(--input-bg);
            border: none;
            border-bottom: 2px solid var(--border-color);
            font-size: 24px;
            font-weight: 800;
            color: var(--input-color);
            text-align: center;
            width: 100%;
            max-width: 220px;
            padding: 5px;
            outline: none;
            text-transform: uppercase;
        }
        input[type="text"]:focus { border-color: var(--accent); }

        /* 2. Lists (Fonts, Symbols, Colors) - Refonte pour la largeur */
        .h-scroll-list {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 5px 2px;
            width: 100%;
            align-items: center;
            justify-content: flex-start;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .h-scroll-list::-webkit-scrollbar { display: none; }

        .list-item {
            flex-shrink: 0;
            height: 44px;
            min-width: 44px;
            border-radius: 10px; 
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--list-item-bg);
            color: var(--nav-btn-color);
            font-size: 18px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        #font-selector .list-item {
            width: 80px !important;
            padding: 0 5px;
            font-weight: 600 !important;
        }
        .list-item.selected {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--accent);
            color: var(--accent);
            transform: scale(1.05);
        }

        /* 3. Key Toggle Button (taille réduite) */
        .key-toggle-btn {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            background: var(--list-item-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: 0.2s;
            position: relative;
            overflow: hidden;
        }
        .key-toggle-btn.active {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }
        .key-toggle-btn.inactive {
            color: #94a3b8;
            border-color: var(--border-color);
            opacity: 0.8;
        }
        .key-toggle-btn.inactive::after {
            content: '';
            position: absolute;
            width: 120%;
            height: 4px;
            background-color: #ef4444;
            transform: rotate(-45deg);
            top: 50%;
            left: -10%;
            box-shadow: 0 0 4px rgba(255,255,255,0.8);
        }

        /* 4. Color Circles (Carrousel compact) */
        .color-circle {
            width: 36px; height: 36px;
            border-radius: 50%;
            cursor: pointer;
            flex-shrink: 0;
            transition: transform 0.2s, box-shadow 0.2s;
            /* Anneau de visibilité par défaut (contraste avec le fond) */
            box-shadow: 0 0 0 2px var(--color-ring);
            border: 2px solid transparent; /* Espace pour l'anneau */
            box-sizing: border-box;
        }
        
        .color-circle.selected {
            transform: scale(1.15);
            /* Anneau de sélection : Couleur Accent + Espace transparent */
            border-color: var(--dock-bg); /* Simule un espace transparent */
            box-shadow: 0 0 0 4px var(--accent);
            z-index: 1;
        }

        /* 5. Sliders */
        .slider-group {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 10px;
        }
        
        input[type="range"] {
            width: 33vw;
            max-width: 200px;
            min-width: 120px;
            height: 12px;
            background: var(--border-color); /* Track color adapted for dark mode */
            border-radius: 6px;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 32px;
            height: 32px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transform: translateY(0);
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }

        /* 6. Export Btn */
        .export-btn {
            background: #10b981;
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            border: none;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        /* Top Buttons */
        .top-btn {
            position: fixed;
            top: 20px;
            width: 44px; height: 44px;
            background: var(--dock-bg);
            color: var(--text-color);
            border-radius: 50%;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            font-size: 22px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: 0.2s;
        }
        #toggle-eye { right: 20px; }
        #toggle-dark { left: 20px; }

        #loader {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0; transition: 0.2s; z-index: 200;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(59, 130, 246, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

    </style>
</head>
<body>

<button id="toggle-dark" class="top-btn"><i class="ph ph-moon"></i></button>
<button id="toggle-eye" class="top-btn"><i class="ph ph-eye"></i></button>

<div id="loader"><div class="spinner"></div></div>

<div id="ui-dock">
    <div class="progress-track"></div>

    <div class="dock-row">
        
        <button class="nav-btn" id="btn-prev">
            <i class="ph ph-arrow-left"></i>
        </button>

        <div class="tool-container">
            
            <div class="step active" data-step="0">
                <div class="step-indicator-icon"><i class="ph ph-pencil-simple"></i></div>
                <input type="text" id="val-name" value="ALEX" maxlength="10" placeholder="NOM">
            </div>

            <div class="step" data-step="1">
                <div class="key-toggle-btn active" id="btn-key-toggle">
                    <i class="ph ph-key"></i>
                </div>
                <input type="hidden" id="val-keychain" value="left_eyelet">
            </div>

            <div class="step" data-step="2">
                <div class="step-indicator-icon"><i class="ph ph-text-aa"></i></div>
                <div class="h-scroll-list" id="font-selector">
                    <div class="list-item selected" data-val="cherry">CHERRY</div>
                    <div class="list-item" data-val="chango">CHANGO</div>
                    <div class="list-item" data-val="lucky">LUCKY</div>
                </div>
                <input type="hidden" id="val-font" value="cherry">
            </div>

            <div class="step" data-step="3">
                <div class="step-indicator-icon"><i class="ph ph-square-fill"></i></div>
                <div class="h-scroll-list center-items" id="palette-body"></div>
                <input type="hidden" id="val-color-body" value="#3498db">
            </div>

            <div class="step" data-step="4">
                <div class="step-indicator-icon"><i class="ph ph-text-t"></i></div>
                <div class="h-scroll-list center-items" id="palette-text"></div>
                <input type="hidden" id="val-color-text" value="#ffffff">
            </div>

            <div class="step" data-step="5">
                <div class="step-indicator-icon"><i class="ph ph-arrows-left-right"></i></div>
                <div class="slider-group">
                    <input type="range" id="val-gap" min="0.85" max="1.3" step="0.01" value="0.98">
                </div>
            </div>

            <div class="step" data-step="6">
                <div class="step-indicator-icon"><i class="ph ph-arrows-clockwise"></i></div>
                <div class="slider-group">
                    <input type="range" id="val-rot" min="-0.25" max="0.25" step="0.01" value="0">
                </div>
            </div>

            <div class="step" data-step="7">
                <div class="step-indicator-icon"><i class="ph ph-chart-bar"></i></div>
                <div class="slider-group">
                    <input type="range" id="val-alt-height" min="-1" max="1" step="0.1" value="0">
                </div>
            </div>

            <div class="step" data-step="8">
                <div class="h-scroll-list" id="symbol-selector">
                    <div class="list-item selected" data-val="none"><i class="ph ph-prohibit"></i></div>
                    <div class="list-item" data-val="star"><i class="ph ph-star"></i></div>
                    <div class="list-item" data-val="heart"><i class="ph ph-heart"></i></div>
                    <div class="list-item" data-val="crown"><i class="ph ph-crown"></i></div>
                    <div class="list-item" data-val="cat"><i class="ph ph-cat"></i></div>
                </div>
                <input type="hidden" id="val-symbol" value="none">
            </div>

            <div class="step" data-step="9">
                <button class="export-btn" id="btn-export">
                    <i class="ph ph-download-simple"></i> Télécharger
                </button>
            </div>

        </div>

        <button class="nav-btn primary" id="btn-next">
            <i class="ph ph-arrow-right"></i>
        </button>

    </div>
</div>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLExporter } from 'three/addons/exporters/STLExporter.js';

    // --- CONFIG ---
    const LETTER_HEIGHT = 12;
    const BODY_THICKNESS = 4;
    const SYMBOL_EXTRUSION = 3;
    const SYMBOL_RADIUS_FACTOR = 0.45; 

    const COLORS_BODY = ['#3498db', '#2ecc71', '#e67e22', '#34495e'];
    const COLORS_TEXT = ['#ffffff', '#f1c40f', '#000000', '#e74c3c'];

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    
    // Paramètres de brouillard Linéaire (repoussés beaucoup plus loin)
    const FOG_NEAR = 750; 
    const FOG_FAR = 1500;
    scene.fog = new THREE.Fog(0xeef2ff, FOG_NEAR, FOG_FAR);
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 90, 110);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // IMPORTANT : Les ombres sont activées
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Ombres douces
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxDistance = 400;
    controls.target.set(0, -10, 0);

    // NOUVEL ÉCLAIRAGE POUR UN MEILLEUR RENDU
    
    // 1. Lumière d'ambiance douce (remplace AmbientLight simple)
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xcccccc, 0.5); // Ciel blanc, Sol gris clair
    scene.add(hemiLight);

    // 2. Lumière directionnelle principale (pour les ombres)
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.8); // Intensité augmentée pour plus de contraste
    dirLight.position.set(40, 80, 60);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048); // Haute résolution
    
    // *** FIX PRINCIPAL: Ajustement du Frustum de la caméra d'ombre ***
    // La valeur "d" définit la taille du volume dans lequel les ombres sont rendues. 
    // Une grande valeur assure que même un long mot est entièrement couvert.
    const shadowCameraSize = 150; 
    dirLight.shadow.camera.left = -shadowCameraSize;
    dirLight.shadow.camera.right = shadowCameraSize;
    dirLight.shadow.camera.top = shadowCameraSize;
    dirLight.shadow.camera.bottom = -shadowCameraSize;
    dirLight.shadow.camera.far = 250; // La distance de la lumière doit être suffisante
    
    scene.add(dirLight);
    
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(600, 600), 
        new THREE.ShadowMaterial({ opacity: 0.06 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.1;
    ground.receiveShadow = true; // IMPORTANT : Le sol reçoit les ombres
    scene.add(ground);

    const matText = new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.05 });
    const matBase = new THREE.MeshPhysicalMaterial({ color: 0x3498db, roughness: 0.6, metalness: 0.05 });
    const mainGroup = new THREE.Group();
    scene.add(mainGroup);

    // --- UI LOGIC ---
    const ui = {
        dock: document.getElementById('ui-dock'),
        steps: document.querySelectorAll('.step'),
        track: document.querySelector('.progress-track'),
        btnPrev: document.getElementById('btn-prev'),
        btnNext: document.getElementById('btn-next'),
        btnEye: document.getElementById('toggle-eye'),
        btnDark: document.getElementById('toggle-dark'),
        btnKey: document.getElementById('btn-key-toggle'),
        loader: document.getElementById('loader'),
        
        keychain: document.getElementById('val-keychain'),
        name: document.getElementById('val-name'),
        font: document.getElementById('val-font'),
        colorBody: document.getElementById('val-color-body'),
        colorText: document.getElementById('val-color-text'),
        gap: document.getElementById('val-gap'),
        rot: document.getElementById('val-rot'),
        altHeight: document.getElementById('val-alt-height'),
        symbol: document.getElementById('val-symbol'),
        exportBtn: document.getElementById('btn-export')
    };

    let currentStep = 0;
    const totalSteps = ui.steps.length;

    for(let i=0; i<totalSteps; i++) {
        const dot = document.createElement('div');
        dot.className = 'prog-dot';
        ui.track.appendChild(dot);
    }
    const dots = document.querySelectorAll('.prog-dot');

    function updateStep() {
        ui.steps.forEach((s, i) => s.classList.toggle('active', i === currentStep));
        dots.forEach((d, i) => {
            d.classList.toggle('active', i === currentStep);
            d.classList.toggle('completed', i < currentStep);
        });
        
        ui.btnPrev.disabled = (currentStep === 0);
        if (currentStep === totalSteps - 1) {
            ui.btnNext.style.opacity = 0;
            ui.btnNext.style.pointerEvents = 'none';
        } else {
            ui.btnNext.style.opacity = 1;
            ui.btnNext.style.pointerEvents = 'all';
        }
    }

    ui.btnPrev.onclick = () => { if(currentStep > 0) { currentStep--; updateStep(); }};
    ui.btnNext.onclick = () => { if(currentStep < totalSteps - 1) { currentStep++; updateStep(); }};
    
    ui.btnEye.onclick = () => {
        ui.dock.classList.toggle('minimized');
        ui.btnEye.innerHTML = ui.dock.classList.contains('minimized') ? '<i class="ph ph-eye-slash"></i>' : '<i class="ph ph-eye"></i>';
    };

    ui.btnDark.onclick = () => {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        ui.btnDark.innerHTML = isDark ? '<i class="ph ph-sun"></i>' : '<i class="ph ph-moon"></i>';
        
        const fogColor = isDark ? 0x0f172a : 0xeef2ff;
        scene.fog = new THREE.Fog(fogColor, FOG_NEAR, FOG_FAR);
    };

    // --- BINDINGS ---
    
    // Key Toggle Logic
    ui.btnKey.onclick = () => {
        const isLeftEyelet = ui.keychain.value === 'left_eyelet';
        if(isLeftEyelet) {
            ui.keychain.value = 'none';
            ui.btnKey.classList.remove('active');
            ui.btnKey.classList.add('inactive');
        } else {
            ui.keychain.value = 'left_eyelet';
            ui.btnKey.classList.add('active');
            ui.btnKey.classList.remove('inactive');
        }
        generateDesign();
    };

    // Selectors
    function setupSelector(id, inputId, callback) {
        document.querySelectorAll(`#${id} .list-item`).forEach(opt => {
            opt.onclick = () => {
                document.querySelectorAll(`#${id} .list-item`).forEach(o => o.classList.remove('selected'));
                document.querySelectorAll(`#${id} .list-item[data-val="${opt.dataset.val}"]`).forEach(o => o.classList.add('selected'));

                document.getElementById(inputId).value = opt.dataset.val;
                if(callback) callback(opt.dataset.val);
                else generateDesign();
            };
        });
    }
    setupSelector('font-selector', 'val-font', changeFont);
    setupSelector('symbol-selector', 'val-symbol');

    // Color Palettes
    function buildPalette(containerId, inputId, colorsArr) {
        const container = document.getElementById(containerId);
        const input = document.getElementById(inputId);
        colorsArr.forEach(c => {
            const btn = document.createElement('div');
            btn.className = 'color-circle';
            btn.style.backgroundColor = c;
            btn.dataset.color = c;
            if(c === input.value) btn.classList.add('selected');
            btn.onclick = () => {
                const allButtons = container.querySelectorAll('.color-circle');
                allButtons.forEach(b => b.classList.remove('selected'));
                
                container.querySelectorAll(`.color-circle[data-color="${c}"]`).forEach(b => b.classList.add('selected'));
                
                input.value = c;
                generateDesign();
            };
            container.appendChild(btn);
        });
    }
    
    // Fonction pour simuler le carrousel "infini" (duplication)
    function enableInfiniteScroll(containerId) {
        const container = document.getElementById(containerId);
        const originalItems = Array.from(container.children);

        for (let i = 0; i < 2; i++) {
            originalItems.forEach(item => {
                const clone = item.cloneNode(true);
                if (item.dataset.val) clone.dataset.val = item.dataset.val;
                if (item.dataset.color) clone.dataset.color = item.dataset.color;
                
                const originalClick = item.onclick;
                if(originalClick) clone.onclick = originalClick;
                
                if (item.classList.contains('selected')) {
                    clone.classList.add('selected');
                } else {
                    clone.classList.remove('selected');
                }

                container.appendChild(clone);
            });
        }
    }


    buildPalette('palette-body', 'val-color-body', COLORS_BODY);
    buildPalette('palette-text', 'val-color-text', COLORS_TEXT);
    
    enableInfiniteScroll('font-selector');
    enableInfiniteScroll('palette-body');
    enableInfiniteScroll('palette-text');
    enableInfiniteScroll('symbol-selector');

    // Fonction pour ajuster la distance de la caméra au bounding box de l'objet
    function fitCameraToSelection(object, controls, paddingFactor = 1.2) {
        const box = new THREE.Box3().setFromObject(object);
        if (box.isEmpty()) return;

        const size = new THREE.Vector3();
        box.getSize(size);
        
        // On prend la plus grande dimension pour garantir que l'objet rentre
        const halfSizeToFitOnScreen = Math.max(size.x, size.y, size.z) / 2;
        const halfFovY = THREE.MathUtils.degToRad(camera.fov / 2);
        let distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
        
        // Ajout d'une marge
        distance *= paddingFactor;

        // Dolly (zoom/dézoom) vers la nouvelle distance tout en conservant l'angle
        controls.dollyTo(distance); 
        
        controls.update();
        camera.updateProjectionMatrix();
    }

    // MISE À JOUR: Binding pour l'écartement (val-gap)
    ui.gap.addEventListener('input', () => {
        generateDesign();
        // Recadrage automatique lors du changement d'écartement
        fitCameraToSelection(mainGroup, controls, 1.3);
    });
    
    // Binding pour les autres paramètres de forme
    [ui.rot, ui.altHeight].forEach(el => el.addEventListener('input', generateDesign));
    ui.name.addEventListener('input', generateDesign);

    // --- 3D LOGIC ---
    let currentFont = null;
    const fontLoader = new FontLoader();
    
    const fontsDB = {
        cherry: './cherry.json',
        chango: './chango.json',
        lucky: './lucky.json'
    };

    function createSymbolMesh(type) {
        const r = LETTER_HEIGHT * SYMBOL_RADIUS_FACTOR;
        let shape = new THREE.Shape();
        if(type === 'star') {
            const inner = r * 0.45;
            for (let i = 0; i < 10; i++) {
                const ang = (i / 10) * Math.PI * 2 - Math.PI/2;
                const rad = (i % 2 === 0) ? r : inner;
                const x = Math.cos(ang) * rad; const y = Math.sin(ang) * rad;
                i === 0 ? shape.moveTo(x, y) : shape.lineTo(x, y);
            }
            shape.closePath();
        } else if(type === 'heart') {
            const x = 0, y = -r*0.3;
            shape.moveTo(x, y + r * 0.6);
            shape.bezierCurveTo(x + r, y + r * 1.4, x + r * 1.6, y, x, y - r);
            shape.bezierCurveTo(x - r * 1.6, y, x - r, y + r * 1.4, x, y + r * 0.6);
        } else if(type === 'crown') {
            shape.moveTo(-r, -r*0.5); shape.lineTo(-r, r*0.2); shape.lineTo(-r*0.5, -r*0.2);
            shape.lineTo(0, r*0.5); shape.lineTo(r*0.5, -r*0.2); shape.lineTo(r, r*0.2);
            shape.lineTo(r, -r*0.5); shape.closePath();
        } else if(type === 'cat') {
            shape.moveTo(-r*0.8, -r*0.6); shape.lineTo(r*0.8, -r*0.6); shape.quadraticCurveTo(r, -r*0.6, r, -r*0.4);
            shape.lineTo(r, 0); shape.lineTo(r*0.8, r*0.8); shape.lineTo(r*0.3, 0.4*r); shape.lineTo(-r*0.3, 0.4*r);
            shape.lineTo(-r*0.8, r*0.8); shape.lineTo(-r, 0); shape.lineTo(-r, -r*0.4); shape.quadraticCurveTo(-r, -r*0.6, -r*0.8, -r*0.6);
        } else return null;
        const geo = new THREE.ExtrudeGeometry(shape, { depth: SYMBOL_EXTRUSION, bevelEnabled: false });
        geo.center();
        const mesh = new THREE.Mesh(geo, matText);
        mesh.castShadow = true; mesh.receiveShadow = true;
        mesh.rotation.x = -Math.PI / 2;
        return mesh;
    }

    function createBaseMesh(width, depth) {
        const shape = new THREE.Shape();
        const r = 3; const w2 = width / 2; const h2 = depth / 2;
        shape.moveTo(-w2 + r, -h2); shape.lineTo(w2 - r, -h2); shape.quadraticCurveTo(w2, -h2, w2, -h2 + r);
        shape.lineTo(w2, h2 - r); shape.quadraticCurveTo(w2, h2, w2 - r, h2); shape.lineTo(-w2 + r, h2);
        shape.quadraticCurveTo(-w2, h2, -w2, h2 - r); shape.lineTo(-w2, -h2 + r); shape.quadraticCurveTo(-w2, -h2, -w2 + r, -h2);
        const geo = new THREE.ExtrudeGeometry(shape, { depth: BODY_THICKNESS, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 4 });
        geo.center();
        const mesh = new THREE.Mesh(geo, matBase);
        mesh.castShadow = true; mesh.receiveShadow = true;
        mesh.rotation.x = -Math.PI / 2;
        return mesh;
    }

    function createKeychainEyelet(width, depth) {
        const tabRadius = 5; const shape = new THREE.Shape();
        shape.moveTo(0, -tabRadius); shape.lineTo(tabRadius * 1.5, -tabRadius); shape.lineTo(tabRadius * 1.5, tabRadius);
        shape.lineTo(0, tabRadius); shape.absarc(0, 0, tabRadius, Math.PI/2, -Math.PI/2, false);
        const hole = new THREE.Path(); hole.absarc(0, 0, tabRadius * 0.45, 0, Math.PI*2, false); shape.holes.push(hole);
        const geo = new THREE.ExtrudeGeometry(shape, { depth: BODY_THICKNESS, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 4 });
        geo.center();
        const mesh = new THREE.Mesh(geo, matBase);
        mesh.castShadow = true; mesh.receiveShadow = true;
        mesh.rotation.x = -Math.PI / 2;
        return mesh;
    }

    function generateDesign() {
        if (!currentFont) return;
        matText.color.set(ui.colorText.value);
        matBase.color.set(ui.colorBody.value);

        while (mainGroup.children.length > 0) {
            const obj = mainGroup.children[0];
            if (obj.geometry) obj.geometry.dispose();
            mainGroup.remove(obj);
        }

        const textStr = (ui.name.value || ' ').toUpperCase();
        const rotVal = parseFloat(ui.rot.value);
        const gapRatio = parseFloat(ui.gap.value);
        const altHeightVal = parseFloat(ui.altHeight.value); 

        const lettersGroup = new THREE.Group();
        let currentX = 0;

        for (let i = 0; i < textStr.length; i++) {
            const char = textStr[i];
            if(char === ' ') { currentX += LETTER_HEIGHT * 0.5; continue; }

            // LOGIQUE HAUTEUR "BALANCE"
            const BASE_H = 2.5;
            const AMPLITUDE = 1.5; 
            let extra = 0;
            
            if(altHeightVal !== 0) {
                const factor = Math.abs(altHeightVal) * AMPLITUDE;
                if(i % 2 === 0) {
                    extra = (altHeightVal < 0) ? factor : -factor * 0.5; 
                } else {
                    extra = (altHeightVal > 0) ? factor : -factor * 0.5;
                }
            }
            
            let finalH = BASE_H + extra;
            if(finalH < 0.5) finalH = 0.5;

            const textGeo = new TextGeometry(char, {
                font: currentFont, size: LETTER_HEIGHT, height: finalH,
                curveSegments: 4, bevelEnabled: true, bevelThickness: 0.3, bevelSize: 0.2, bevelSegments: 2
            });
            textGeo.computeBoundingBox();
            const xSize = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
            const ySize = textGeo.boundingBox.max.y - textGeo.boundingBox.min.y;
            textGeo.translate(-xSize/2, -ySize/2, 0);
            
            const mesh = new THREE.Mesh(textGeo, matText);
            mesh.rotation.x = -Math.PI / 2;
            mesh.rotation.z = (i % 2 === 0) ? rotVal : -rotVal;
            mesh.position.set(currentX + xSize/2, BODY_THICKNESS, 0);
            mesh.castShadow = true; mesh.receiveShadow = true;
            lettersGroup.add(mesh);
            currentX += (xSize * gapRatio) + (LETTER_HEIGHT * 0.1);
        }

        const contentGroup = new THREE.Group();
        contentGroup.add(lettersGroup);

        const symType = ui.symbol.value;
        if (symType !== 'none') {
            const symMesh = createSymbolMesh(symType);
            if (symMesh) {
                const lettersBox = new THREE.Box3().setFromObject(lettersGroup);
                let lettersMaxX = lettersBox.isEmpty() ? 0 : lettersBox.max.x;
                const symBox = new THREE.Box3().setFromObject(symMesh);
                const symW = symBox.max.x - symBox.min.x;
                symMesh.position.set(lettersMaxX + (LETTER_HEIGHT * 0.6) + symW/2, BODY_THICKNESS, 0);
                contentGroup.add(symMesh);
            }
        }

        const contentBox = new THREE.Box3().setFromObject(contentGroup);
        const contentW = contentBox.isEmpty() ? 10 : (contentBox.max.x - contentBox.min.x);
        const baseW = contentW + 20;
        const baseZ = LETTER_HEIGHT + 16;
        const baseMesh = createBaseMesh(baseW, baseZ);
        const centerX = contentBox.isEmpty() ? 0 : (contentBox.min.x + contentW / 2);
        baseMesh.position.set(centerX, BODY_THICKNESS/2, 0); 

        const fullPiece = new THREE.Group();
        fullPiece.add(baseMesh);
        fullPiece.add(contentGroup);

        if (ui.keychain.value === 'left_eyelet') {
            const eyelet = createKeychainEyelet(baseW, baseZ);
            const leftEdgeX = centerX - (baseW / 2);
            eyelet.position.set(leftEdgeX - 1, BODY_THICKNESS/2, 0);
            fullPiece.add(eyelet);
        }

        const box = new THREE.Box3().setFromObject(fullPiece);
        if (!box.isEmpty()) {
            const center = new THREE.Vector3();
            box.getCenter(center);
            fullPiece.position.sub(center);
            const newBox = new THREE.Box3().setFromObject(fullPiece);
            fullPiece.position.y -= newBox.min.y;
        }
        mainGroup.add(fullPiece);
    }

    function changeFont(key) {
        ui.loader.style.opacity = 1;
        fontLoader.load(fontsDB[key], (font) => {
            currentFont = font;
            generateDesign();
            ui.loader.style.opacity = 0;
            const box = new THREE.Box3().setFromObject(mainGroup);
            if (!box.isEmpty()) {
                const size = new THREE.Vector3(); box.getSize(size);
                const max = Math.max(size.x, size.y, size.z);
                controls.minDistance = max;
                
                // Recadrer la vue sur le nouvel objet après le chargement de la police
                fitCameraToSelection(mainGroup, controls, 1.3);
            }
        });
    }

    ui.exportBtn.onclick = () => {
        if (mainGroup.children.length === 0) return;
        const exporter = new STLExporter();
        const result = exporter.parse(mainGroup, { binary: true });
        const cleanName = (ui.name.value || 'MODEL').replace(/[^a-zA-Z0-9]/g, '_');
        const blob = new Blob([result], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${cleanName}.stl`;
        link.click();
    };

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    changeFont('cherry');
    updateStep();
    animate();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Configurateur USB 3D (Mobile)</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <style>
        /* BASE */
        body {
            margin: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background-color: #f0f0f0;
        }

        /* Canvas plein écran */
        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        /* Panneau UI (droite, scrollable, mobile friendly) */
        #ui-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 210px;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.96);
            box-shadow: -6px 0 14px rgba(0, 0, 0, 0.15);
            z-index: 10;
            overflow-y: auto;
            transition: transform 0.25s ease-out;
        }

        /* Quand masqué (slider hors écran à droite) */
        #ui-container.hidden {
            transform: translateX(100%);
        }

        /* Bouton flottant pour afficher / masquer l’UI (innov smartphone) */
        #toggle-ui {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 15;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #toggle-ui:active {
            transform: scale(0.96);
        }

        h1 {
            font-size: 18px;
            margin: 0 0 12px 0;
            text-align: center;
            color: #333;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #444;
            margin-bottom: 4px;
        }

        select,
        input[type="text"],
        input[type="range"] {
            width: 100%;
            padding: 6px;
            margin-bottom: 5px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 13px;
        }

        input[type="range"] {
            padding: 0;
        }

        #exportStlButton {
            width: 100%;
            padding: 9px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 14px;
        }

        #exportStlButton:active {
            transform: scale(0.97);
        }

        #loading-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 14px;
            border-radius: 6px;
            z-index: 20;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        /* Mode paysage très bas (ex : smartphone couché) */
        @media (orientation: landscape) and (max-height: 500px) {
            #ui-container {
                width: 190px;
                padding: 6px;
            }
            h1 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            label {
                font-size: 11px;
            }
            select,
            input[type="text"],
            input[type="range"] {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>

<!-- Bouton flottant pour afficher / cacher les contrôles -->
<button id="toggle-ui">⚙</button>

<div id="ui-container">
    <h1>Configurateur USB</h1>

    <div class="control-group">
        <label>STYLE DE POLICE</label>
        <select id="selectFont">
            <option value="luckiest">Luckiest Guy</option>
            <option value="cherry">Cherry Bomb One</option>
        </select>
    </div>

    <div class="control-group">
        <label>COULEUR DU CORPS (Socle)</label>
        <select id="selectColorBody">
            <option value="#3498db">Bleu Classique</option>
            <option value="#2ecc71">Vert Émeraude</option>
            <option value="#f39c12">Orange Vif</option>
            <option value="#ecf0f1">Gris Clair</option>
        </select>
    </div>

    <div class="control-group">
        <label>COULEUR DU TEXTE</label>
        <select id="selectColorText">
            <option value="#e74c3c">Rouge Carmin</option>
            <option value="#9b59b6">Violet Améthyste</option>
            <option value="#f1c40f">Jaune Or</option>
            <option value="#34495e">Gris Profond</option>
        </select>
    </div>

    <div class="control-group">
        <label>PRÉNOM</label>
        <input type="text" id="inputName" value="ALEX" maxlength="10">
    </div>

    <div class="control-group">
        <label>ÉCARTEMENT DES LETTRES</label>
        <input type="range" id="sliderGapRatio" min="0.85" max="1.05" step="0.01" value="0.95">
    </div>

    <div class="control-group">
        <label>ROTATION (Wiggle)</label>
        <input type="range" id="sliderRot" min="-0.3" max="0.3" step="0.01" value="0">
    </div>

    <div class="control-group">
        <label>HAUTEUR (Volume)</label>
        <input type="range" id="sliderHeight" min="-2.5" max="2.5" step="0.1" value="0">
    </div>

    <button id="exportStlButton">Télécharger STL</button>
</div>

<div id="loading-msg">Chargement des polices...</div>
<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.154.0';
    import { FontLoader } from 'https://esm.sh/three@0.154.0/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'https://esm.sh/three@0.154.0/examples/jsm/geometries/TextGeometry.js';
    import { OrbitControls } from 'https://esm.sh/three@0.154.0/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://esm.sh/three@0.154.0/examples/jsm/exporters/STLExporter.js';

    // --- CONSTANTES GLOBALES ---
    const LETTER_HEIGHT = 10;
    const BODY_THICKNESS = 4;
    const PLUG_COLOR = 0x808080;
    const PLUG_THICKNESS = BODY_THICKNESS * 0.5; // gardé même si pas encore utilisé

    // --- SCÈNE / CAMÉRA / RENDERER ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
    );
    camera.position.set(0, 80, 140);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.7;
    controls.zoomSpeed = 0.6;

    // --- LUMIÈRES ---
    const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
    mainLight.position.set(50, 50, 30);
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.8);
    fillLight.position.set(-50, 20, -10);
    scene.add(fillLight);

    // --- MATÉRIAUX ---
    const matPlastic = new THREE.MeshPhysicalMaterial({
        color: 0x1E90FF,
        roughness: 0.8,
        metalness: 0.1,
        clearcoat: 0.5,
        clearcoatRoughness: 0.1
    });

    const matBody = new THREE.MeshPhysicalMaterial({
        color: 0x3498db,
        roughness: 0.9,
        metalness: 0.1
    });

    const matMetal = new THREE.MeshStandardMaterial({
        color: PLUG_COLOR,
        roughness: 0.5,
        metalness: 0.7
    });
    // ground supprimé pour ne pas élargir la bounding box de centrage

    // --- GESTION DES POLICES ---
    let currentFont = null;
    const fontLoader = new FontLoader();
    const fontsDatabase = {
        luckiest: 'luckiest.json',
        cherry: 'cherry.json'
    };

    const mainGroup = new THREE.Group();
    scene.add(mainGroup);

    // On ne recadre la caméra qu'une seule fois
    let hasFittedOnce = false;

    // --- RÉFÉRENCES UI ---
    const elName = document.getElementById('inputName');
    const elFont = document.getElementById('selectFont');
    const elMsg = document.getElementById('loading-msg');
    const elColorBody = document.getElementById('selectColorBody');
    const elColorText = document.getElementById('selectColorText');
    const elRot = document.getElementById('sliderRot');
    const elHeight = document.getElementById('sliderHeight');
    const elGapRatio = document.getElementById('sliderGapRatio');
    const elExportStlButton = document.getElementById('exportStlButton');
    const toggleUIButton = document.getElementById('toggle-ui');
    const uiContainer = document.getElementById('ui-container');

    // --- FONCTIONS UTILES ---

    // centre un group autour de l'origine, sans changer sa forme
    function centerGroupAtOrigin(group) {
        const box = new THREE.Box3().setFromObject(group);
        if (box.isEmpty()) return;
        const center = new THREE.Vector3();
        box.getCenter(center);
        group.position.sub(center);
    }

    // ajuste la caméra pour que l'objet soit bien dans le cadre
    function fitCameraToObject(object3D) {
        const box = new THREE.Box3().setFromObject(object3D);
        if (box.isEmpty()) return;

        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let dist = (maxDim / 2) / Math.tan(fov / 2);
        dist *= 1.4; // petite marge

        camera.position.set(center.x, center.y + dist * 0.25, center.z + dist);
        camera.near = dist / 10;
        camera.far = dist * 10;
        camera.updateProjectionMatrix();

        controls.target.copy(center);
        controls.update();
    }

    // --- GÉNÉRATION DU MODÈLE ---
    function generateUSB() {
        if (!currentFont) {
            elMsg.style.display = 'block';
            return;
        }
        elMsg.style.display = 'none';

        // Mise à jour couleurs
        matPlastic.color.set(elColorText.value);
        matBody.color.set(elColorBody.value);

        // Nettoyage de l'ancien modèle
        while (mainGroup.children.length > 0) {
            const obj = mainGroup.children[0];
            if (obj.geometry) obj.geometry.dispose();
            mainGroup.remove(obj);
        }

        const LETTER_EXTRUSION_BASE = 2.5;
        const BEVEL_THICKNESS = 0.2;
        const BEVEL_SIZE = 0.1;

        const textStr = (elName.value || ' ').toUpperCase();
        const rotVal = parseFloat(elRot.value);
        const heightVal = parseFloat(elHeight.value);
        const gapRatio = parseFloat(elGapRatio.value);

        let currentX = 0;
        const lettersGroup = new THREE.Group();

        for (let i = 0; i < textStr.length; i++) {
            const char = textStr[i];
            const isPair = (i % 2 === 0);

            let extrusionDepth = LETTER_EXTRUSION_BASE + (isPair ? heightVal : -heightVal);
            if (extrusionDepth < 0.5) extrusionDepth = 0.5;

            const textGeo = new TextGeometry(char, {
                font: currentFont,
                size: LETTER_HEIGHT,
                height: extrusionDepth,
                curveSegments: 6,
                bevelEnabled: true,
                bevelThickness: BEVEL_THICKNESS,
                bevelSize: BEVEL_SIZE,
                bevelSegments: 2
            });

            textGeo.computeBoundingBox();
            const xSize = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
            const ySize = textGeo.boundingBox.max.y - textGeo.boundingBox.min.y;

            // même centrage que ton code (translate + center)
            textGeo.translate(-xSize / 2, -ySize / 2, 0);
            textGeo.center();

            const mesh = new THREE.Mesh(textGeo, matPlastic);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.rotation.x = -Math.PI / 2;
            mesh.rotation.z = isPair ? rotVal : -rotVal;

            mesh.position.set(currentX + xSize / 2, BODY_THICKNESS, 0);
            lettersGroup.add(mesh);

            currentX += (xSize * gapRatio);
        }

        // largeur de toutes les lettres
        const bbox = new THREE.Box3().setFromObject(lettersGroup);
        const wideX = bbox.max.x - bbox.min.x;

        const MARGIN_X = 8;
        const MARGIN_Z = 4;

        const bodyW = wideX + MARGIN_X;
        const bodyZDepth = LETTER_HEIGHT + MARGIN_Z;

        // socle
        const bodyGeo = new THREE.BoxGeometry(bodyW, BODY_THICKNESS, bodyZDepth);
        const bodyMesh = new THREE.Mesh(bodyGeo, matBody);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;

        const centerXOffset = bbox.min.x + (wideX / 2);
        bodyMesh.position.set(centerXOffset, BODY_THICKNESS / 2, 0);

        // on regroupe lettre + socle dans un group pour les centrer proprement
        const pieceGroup = new THREE.Group();
        pieceGroup.add(bodyMesh);
        pieceGroup.add(lettersGroup);

        // centre la pièce autour de (0,0,0) SANS changer sa forme / proportion
        centerGroupAtOrigin(pieceGroup);

        // ajoute au groupe principal
        mainGroup.add(pieceGroup);

        // ⚠️ NE PLUS RECENTRER LA CAMÉRA ICI
        // fitCameraToObject(mainGroup);
    }

    // --- EXPORT STL ---
    function save(blob, filename) {
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        document.body.removeChild(link);
    }

    function exportStl() {
        if (mainGroup.children.length === 0) return;
        const exporter = new STLExporter();
        const result = exporter.parse(mainGroup, { binary: true });
        const name = (elName.value || 'USB_CLE').toUpperCase();
        save(new Blob([result], { type: 'application/octet-stream' }), `${name}_modele.stl`);
    }

    // --- CHARGEMENT DES POLICES ---
    function changeFont(fontKey) {
        const url = fontsDatabase[fontKey];
        if (!url) return;

        elMsg.style.display = 'block';
        elMsg.innerText = `Chargement police : ${fontKey}...`;

        fontLoader.load(
            url,
            function (font) {
                currentFont = font;
                elMsg.style.display = 'none';
                generateUSB();

                // On ne recadre la caméra qu'une seule fois (au premier rendu)
                if (!hasFittedOnce) {
                    fitCameraToObject(mainGroup);
                    hasFittedOnce = true;
                }
            },
            undefined,
            function (err) {
                console.error(`Erreur Critique de Chargement Police pour ${fontKey}:`, err);
                elMsg.innerText = `Erreur de chargement pour ${fontKey}.`;
            }
        );
    }

    // --- ÉCOUTEURS ---
    elName.addEventListener('input', generateUSB);
    elFont.addEventListener('change', (e) => changeFont(e.target.value));
    elColorBody.addEventListener('change', generateUSB);
    elColorText.addEventListener('change', generateUSB);
    elRot.addEventListener('input', generateUSB);
    elHeight.addEventListener('input', generateUSB);
    elGapRatio.addEventListener('input', generateUSB);
    elExportStlButton.addEventListener('click', exportStl);

    // Bouton pour masquer / montrer l’UI (smartphone friendly)
    toggleUIButton.addEventListener('click', () => {
        uiContainer.classList.toggle('hidden');
    });

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        // On NE recadre PAS la caméra ici pour conserver le point de vue
    });

    // --- BOUCLE D’ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // --- LANCEMENT INITIAL ---
    elMsg.style.display = 'block';
    changeFont('luckiest');
</script>


</body>
</html>

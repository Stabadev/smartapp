<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Configurateur USB 3D (Mobile)</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <style>
        /* BASE */
        body {
            margin: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #ffffff 0%, #e0e7ff 45%, #c7d2fe 75%, #94a3b8 100%);
        }

        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        #ui-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 210px;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.96);
            backdrop-filter: blur(8px);
            box-shadow: -6px 0 14px rgba(0, 0, 0, 0.15);
            z-index: 10;
            overflow-y: auto;
            transition: transform 0.25s ease-out;
        }

        #ui-container.hidden {
            transform: translateX(100%);
        }

        #toggle-ui {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 15;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #toggle-ui:active {
            transform: scale(0.96);
        }

        h1 {
            font-size: 18px;
            margin: 0 0 12px 0;
            text-align: center;
            color: #333;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #444;
            margin-bottom: 4px;
        }

        select,
        input[type="text"],
        input[type="range"] {
            width: 100%;
            padding: 6px;
            margin-bottom: 5px;
            box-sizing: border-box;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 13px;
        }

        input[type="range"] {
            padding: 0;
        }

        #exportStlButton {
            width: 100%;
            padding: 9px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            font-size: 14px;
        }

        #exportStlButton:active {
            transform: scale(0.97);
        }

        #loading-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 14px;
            border-radius: 6px;
            z-index: 20;
            font-size: 14px;
            text-align: center;
            display: none;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            #ui-container {
                width: 210px;
                height: 100vh;
                padding: 10px;
                padding-bottom: 80px;
                box-sizing: border-box;
                background: rgba(255, 255, 255, 0.96);
                box-shadow: -6px 0 14px rgba(0, 0, 0, 0.15);
                z-index: 10;
                overflow-y: auto;
                transition: transform 0.25s ease-out;
            }
            h1 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            label {
                font-size: 11px;
            }
            select,
            input[type="text"],
            input[type="range"] {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>

<button id="toggle-ui">⚙</button>

<div id="ui-container">
    <h1>Configurateur USB</h1>

    <div class="control-group">
        <label>STYLE DE POLICE</label>
        <select id="selectFont">
            <option value="luckiest">Luckiest Guy</option>
            <option value="cherry">Cherry Bomb One</option>
        </select>
    </div>

    <div class="control-group">
        <label>COULEUR DU CORPS (Socle)</label>
        <select id="selectColorBody">
            <option value="#3498db">Bleu Classique</option>
            <option value="#2ecc71">Vert Émeraude</option>
            <option value="#f39c12">Orange Vif</option>
            <option value="#868F92">Gris Clair</option>
        </select>
    </div>

    <div class="control-group">
        <label>COULEUR DU TEXTE</label>
        <select id="selectColorText">
            <option value="#e74c3c">Rouge Carmin</option>
            <option value="#9b59b6">Violet Améthyste</option>
            <option value="#f1c40f">Jaune Or</option>
            <option value="#34495e">Gris Profond</option>
        </select>
    </div>

    <div class="control-group">
        <label>PRÉNOM</label>
        <input type="text" id="inputName" value="ALEX" maxlength="10">
    </div>

    <div class="control-group">
        <label>SYMBOLE</label>
        <select id="selectSymbol">
            <option value="none">Aucun symbole</option>
            <option value="star">Étoile</option>
            <option value="circle">Rond</option>
            <option value="diamond">Losange</option>
            <option value="heart">Cœur</option>
            <option value="square">Carré</option>
            <option value="triangle">Triangle</option>
        </select>
    </div>

    <div class="control-group">
        <label>MODE PORTE-CLÉ</label>
        <select id="selectKeychain">
            <option value="none">Sans porte-clé</option>
            <option value="left_eyelet">Porte-clé (œillet à gauche)</option>
        </select>
    </div>



    <div class="control-group">
        <label>ÉCARTEMENT DES LETTRES</label>
        <input type="range" id="sliderGapRatio" min="0.85" max="1.3" step="0.01" value="0.95">
    </div>

    <div class="control-group">
        <label>ROTATION (Wiggle)</label>
        <input type="range" id="sliderRot" min="-0.3" max="0.3" step="0.01" value="0">
    </div>

    <div class="control-group">
        <label>HAUTEUR (Volume)</label>
        <input type="range" id="sliderHeight" min="-0.9" max="1" step="0.1" value="0">
    </div>

    <button id="exportStlButton">Télécharger STL</button>
</div>

<div id="loading-msg">Chargement des polices...</div>
<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.154.0';
    import { FontLoader } from 'https://esm.sh/three@0.154.0/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'https://esm.sh/three@0.154.0/examples/jsm/geometries/TextGeometry.js';
    import { OrbitControls } from 'https://esm.sh/three@0.154.0/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://esm.sh/three@0.154.0/examples/jsm/exporters/STLExporter.js';

    const LETTER_HEIGHT = 10;
    const BODY_THICKNESS = 4;
    const PLUG_COLOR = 0x808080;
    const PLUG_THICKNESS = BODY_THICKNESS * 0.5;

    const SYMBOL_EXTRUSION = 2.5;           // hauteur fixe du symbole
    const SYMBOL_RADIUS_FACTOR = 0.35;      // taille symbole / hauteur lettre

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
    );
    camera.position.set(0, 80, 140);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.7;
    controls.zoomSpeed = 0.6;

    const ambLight = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(ambLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 1.35);
    mainLight.position.set(40, 80, 50);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    mainLight.shadow.camera.near = 10;
    mainLight.shadow.camera.far = 200;
    mainLight.shadow.camera.left = -80;
    mainLight.shadow.camera.right = 80;
    mainLight.shadow.camera.top = 80;
    mainLight.shadow.camera.bottom = -80;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.55);
    fillLight.position.set(-40, 40, -30);
    scene.add(fillLight);

    const rimLight = new THREE.DirectionalLight(0xffffff, 0.35);
    rimLight.position.set(0, 60, -80);
    scene.add(rimLight);

    const groundGeo = new THREE.PlaneGeometry(400, 400);
    const groundMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.95,
        metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -BODY_THICKNESS * 1.2;
    ground.receiveShadow = true;
    scene.add(ground);

    const matPlastic = new THREE.MeshPhysicalMaterial({
        color: 0x1E90FF,
        roughness: 0.45,
        metalness: 0.25,
        clearcoat: 0.6,
        clearcoatRoughness: 0.1
    });

    const matBody = new THREE.MeshPhysicalMaterial({
        color: 0x3498db,
        roughness: 0.75,
        metalness: 0.1,
        clearcoat: 0.3,
        clearcoatRoughness: 0.2
    });

    const matMetal = new THREE.MeshStandardMaterial({
        color: PLUG_COLOR,
        roughness: 0.35,
        metalness: 0.85
    });

    let currentFont = null;
    const fontLoader = new FontLoader();
    const fontsDatabase = {
        luckiest: 'luckiest.json',
        cherry: 'cherry.json'
    };

    const mainGroup = new THREE.Group();
    scene.add(mainGroup);

    let hasFittedOnce = false;

    const elName = document.getElementById('inputName');
    const elFont = document.getElementById('selectFont');
    const elMsg = document.getElementById('loading-msg');
    const elColorBody = document.getElementById('selectColorBody');
    const elColorText = document.getElementById('selectColorText');
    const elRot = document.getElementById('sliderRot');
    const elHeight = document.getElementById('sliderHeight');
    const elGapRatio = document.getElementById('sliderGapRatio');
    const elSymbol = document.getElementById('selectSymbol');
    const elKeychain = document.getElementById('selectKeychain');

    const elExportStlButton = document.getElementById('exportStlButton');
    const toggleUIButton = document.getElementById('toggle-ui');
    const uiContainer = document.getElementById('ui-container');

    function centerGroupAtOrigin(group) {
        const box = new THREE.Box3().setFromObject(group);
        if (box.isEmpty()) return;
        const center = new THREE.Vector3();
        box.getCenter(center);
        group.position.sub(center);
    }

    function fitCameraToObject(object3D) {
        const box = new THREE.Box3().setFromObject(object3D);
        if (box.isEmpty()) return;

        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        let dist = (maxDim / 2) / Math.tan(fov / 2);
        dist *= 1.4;

        camera.position.set(center.x, center.y + dist * 0.25, center.z + dist);
        camera.near = dist / 10;
        camera.far = dist * 10;
        camera.updateProjectionMatrix();

        controls.target.copy(center);
        controls.update();
    }

    // Tous les symboles sont des Shape extrudés → à plat comme les lettres
    function createSymbolMesh(type) {
        const r = LETTER_HEIGHT * SYMBOL_RADIUS_FACTOR;
        let shape = null;

        if (type === 'star') {
            const innerRadius = r * 0.45;
            shape = new THREE.Shape();
            const numPoints = 5;
            for (let i = 0; i < numPoints * 2; i++) {
                const angle = (i / (numPoints * 2)) * Math.PI * 2;
                const radius = (i % 2 === 0) ? r : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }
            shape.closePath();
        } else if (type === 'circle') {
            shape = new THREE.Shape();
            shape.absarc(0, 0, r, 0, Math.PI * 2, false);
        } else if (type === 'diamond') {
            shape = new THREE.Shape();
            shape.moveTo(0, r);
            shape.lineTo(r, 0);
            shape.lineTo(0, -r);
            shape.lineTo(-r, 0);
            shape.closePath();
        } else if (type === 'square') {
            shape = new THREE.Shape();
            const s = r;
            shape.moveTo(-s, -s);
            shape.lineTo(s, -s);
            shape.lineTo(s, s);
            shape.lineTo(-s, s);
            shape.closePath();
        } else if (type === 'triangle') {
            shape = new THREE.Shape();
            const h = r * 1.1;
            shape.moveTo(0, h);
            shape.lineTo(-r, -h * 0.4);
            shape.lineTo(r, -h * 0.4);
            shape.closePath();
        } else if (type === 'heart') {
            shape = new THREE.Shape();
            const x = 0, y = 0;
            const hr = r;
            shape.moveTo(x, y + hr * 0.6);
            shape.bezierCurveTo(
                x + hr, y + hr * 1.4,
                x + hr * 1.6, y,
                x, y - hr
            );
            shape.bezierCurveTo(
                x - hr * 1.6, y,
                x - hr, y + hr * 1.4,
                x, y + hr * 0.6
            );
        }

        if (!shape) return null;

        const extrudeSettings = {
            depth: SYMBOL_EXTRUSION,
            bevelEnabled: false
        };

        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geo.center();

        const mesh = new THREE.Mesh(geo, matPlastic);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Aligné comme les lettres : posé à plat sur le socle
        mesh.rotation.x = -Math.PI / 2;

        return mesh;
    }

    // Base rectangulaire, avec ou sans chanfrein
 function createBaseMesh(bodyW, bodyZDepth) {
    const geo = new THREE.BoxGeometry(bodyW, BODY_THICKNESS, bodyZDepth);
    const mesh = new THREE.Mesh(geo, matBody);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
}


    // Oeillet de porte-clé à gauche, même largeur (Z) que la base
function createKeychainEyeletLeft(bodyW, bodyZDepth, centerXOffset) {
    const tabW = BODY_THICKNESS * 3.2;        // longueur de la languette (en X)
    const tabZ = bodyZDepth;                  // même largeur que la base (en Z)
    const halfW = tabW / 2;
    const halfZ = tabZ / 2;

    const shape = new THREE.Shape();

    // --- Paramètres du trou (on garde ta logique) ---
    const holeRadius = Math.min(halfW, halfZ) * 0.55;
    const holeCenterX = -halfW * -0.15;   // = +0.15 * halfW

    // Rayon des coins arrondis côté GAUCHE uniquement
    const cornerRadius = Math.min(holeRadius, halfZ * 0.6);

    // --- Contour avec côtés droits à droite, arrondis à gauche ---

    // On part en bas à droite
    shape.moveTo(halfW, -halfZ);

    // Côté droit (vertical, sans arrondi)
    shape.lineTo(halfW, halfZ);

    // Bord haut, de droite vers gauche jusqu'au début de l'arrondi
    shape.lineTo(-halfW + cornerRadius, halfZ);

    // Arrondi coin haut-gauche
    shape.quadraticCurveTo(-halfW, halfZ, -halfW, halfZ - cornerRadius);

    // Côté gauche, vers le bas jusqu'au début de l'arrondi bas
    shape.lineTo(-halfW, -halfZ + cornerRadius);

    // Arrondi coin bas-gauche
    shape.quadraticCurveTo(-halfW, -halfZ, -halfW + cornerRadius, -halfZ);

    // Bord bas, retour vers la droite
    shape.lineTo(halfW, -halfZ);

    shape.closePath();

    // --- Trou circulaire (comme tu l'avais) ---
    const hole = new THREE.Path();
    hole.absarc(holeCenterX, 0, holeRadius, 0, Math.PI * 2, false);
    shape.holes.push(hole);

    const extrudeSettings = {
        depth: BODY_THICKNESS,
        bevelEnabled: false
    };

    const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geo.center();

    const mesh = new THREE.Mesh(geo, matBody);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    // posé à plat
    mesh.rotation.x = -Math.PI / 2;

    // position : collé au bord GAUCHE du socle
    const tabCenterX = centerXOffset - bodyW / 2 - halfW * 0.7; // léger chevauchement
    mesh.position.set(tabCenterX, BODY_THICKNESS / 2, 0);

    return mesh;
}

    function generateUSB() {
        if (!currentFont) {
            elMsg.style.display = 'block';
            return;
        }
        elMsg.style.display = 'none';

        matPlastic.color.set(elColorText.value);
        matBody.color.set(elColorBody.value);

        while (mainGroup.children.length > 0) {
            const obj = mainGroup.children[0];
            if (obj.geometry) obj.geometry.dispose();
            mainGroup.remove(obj);
        }

        const LETTER_EXTRUSION_BASE = 2.5;
        const BEVEL_THICKNESS = 0.2;
        const BEVEL_SIZE = 0.1;

        const textStr = (elName.value || ' ').toUpperCase();
        const rotVal = parseFloat(elRot.value);
        const heightVal = parseFloat(elHeight.value);
        const gapRatio = parseFloat(elGapRatio.value);
        const symbolType = elSymbol.value;
        const keychainMode = elKeychain.value;


        let currentX = 0;
        const lettersGroup = new THREE.Group();

        for (let i = 0; i < textStr.length; i++) {
            const char = textStr[i];
            const isPair = (i % 2 === 0);

            let extrusionDepth = LETTER_EXTRUSION_BASE + (isPair ? heightVal : -heightVal);
            if (extrusionDepth < 0.5) extrusionDepth = 0.5;

            const textGeo = new TextGeometry(char, {
                font: currentFont,
                size: LETTER_HEIGHT,
                height: extrusionDepth,
                curveSegments: 6,
                bevelEnabled: true,
                bevelThickness: BEVEL_THICKNESS,
                bevelSize: BEVEL_SIZE,
                bevelSegments: 2
            });

            textGeo.computeBoundingBox();
            const xSize = textGeo.boundingBox.max.x - textGeo.boundingBox.min.x;
            const ySize = textGeo.boundingBox.max.y - textGeo.boundingBox.min.y;

            textGeo.translate(-xSize / 2, -ySize / 2, 0);
            textGeo.center();

            const mesh = new THREE.Mesh(textGeo, matPlastic);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            mesh.rotation.x = -Math.PI / 2;
            mesh.rotation.z = isPair ? rotVal : -rotVal;

            mesh.position.set(currentX + xSize / 2, BODY_THICKNESS, 0);
            lettersGroup.add(mesh);

            currentX += (xSize * gapRatio);
        }

        const lettersBox = new THREE.Box3().setFromObject(lettersGroup);
        const contentGroup = new THREE.Group();
        contentGroup.add(lettersGroup);

        if (symbolType !== 'none') {
            const symbolMesh = createSymbolMesh(symbolType);
            if (symbolMesh) {
                const symBox0 = new THREE.Box3().setFromObject(symbolMesh);
                const symWidth = symBox0.max.x - symBox0.min.x;
                const symbolOffsetX = lettersBox.max.x + symWidth * 0.6;
                symbolMesh.position.set(symbolOffsetX, BODY_THICKNESS, 0);
                contentGroup.add(symbolMesh);
            }
        }

        const contentBox = new THREE.Box3().setFromObject(contentGroup);
        const wideX = contentBox.max.x - contentBox.min.x;

        const MARGIN_X = 8;
        const MARGIN_Z = 4;

        const bodyW = wideX + MARGIN_X;
        const bodyZDepth = LETTER_HEIGHT + MARGIN_Z;

        const bodyMesh = createBaseMesh(bodyW, bodyZDepth);

        const centerXOffset = contentBox.min.x + (wideX / 2);
        bodyMesh.position.set(centerXOffset, BODY_THICKNESS / 2, 0);

        const pieceGroup = new THREE.Group();
        pieceGroup.add(bodyMesh);
        pieceGroup.add(contentGroup);

        // Ajout de l’œillet porte-clé à GAUCHE
        if (keychainMode === 'left_eyelet') {
            const eyelet = createKeychainEyeletLeft(bodyW, bodyZDepth, centerXOffset);
            pieceGroup.add(eyelet);
        }

        centerGroupAtOrigin(pieceGroup);
        mainGroup.add(pieceGroup);
    }

    function save(blob, filename) {
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        document.body.removeChild(link);
    }

    function exportStl() {
        if (mainGroup.children.length === 0) return;
        const exporter = new STLExporter();
        const result = exporter.parse(mainGroup, { binary: true });
        const name = (elName.value || 'USB_CLE').toUpperCase();
        save(new Blob([result], { type: 'application/octet-stream' }), `${name}_modele.stl`);
    }

    function changeFont(fontKey) {
        const url = fontsDatabase[fontKey];
        if (!url) return;

        elMsg.style.display = 'block';
        elMsg.innerText = `Chargement police : ${fontKey}...`;

        fontLoader.load(
            url,
            function (font) {
                currentFont = font;
                elMsg.style.display = 'none';
                generateUSB();

                if (!hasFittedOnce) {
                    fitCameraToObject(mainGroup);
                    hasFittedOnce = true;
                }
            },
            undefined,
            function (err) {
                console.error(`Erreur Critique de Chargement Police pour ${fontKey}:`, err);
                elMsg.innerText = `Erreur de chargement pour ${fontKey}.`;
            }
        );
    }

    elName.addEventListener('input', generateUSB);
    elFont.addEventListener('change', (e) => changeFont(e.target.value));
    elColorBody.addEventListener('change', generateUSB);
    elColorText.addEventListener('change', generateUSB);
    elRot.addEventListener('input', generateUSB);
    elHeight.addEventListener('input', generateUSB);
    elGapRatio.addEventListener('input', generateUSB);
    elSymbol.addEventListener('change', generateUSB);
    elKeychain.addEventListener('change', generateUSB);
    elExportStlButton.addEventListener('click', exportStl);

    toggleUIButton.addEventListener('click', () => {
        uiContainer.classList.toggle('hidden');
    });

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    elMsg.style.display = 'block';
    changeFont('luckiest');
</script>

</body>
</html>
